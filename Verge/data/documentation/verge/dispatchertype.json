{"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"DispatcherType"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"Scope"},{"kind":"text","text":"> = "},{"kind":"typeIdentifier","identifier":"doc:\/\/Verge\/documentation\/Verge\/StoreDriverType","preciseIdentifier":"s:5Verge15StoreDriverTypeP","text":"StoreDriverType"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Scope"},{"kind":"text","text":">"}],"languages":["swift"],"platforms":["macOS"]}]},{"kind":"content","content":[{"anchor":"discussion","level":2,"type":"heading","text":"Discussion"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Dispatcher is"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"it is an object."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"it does not have its own state."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"it can run commit with specified store’s state."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"it can have a temporary dependency to commit the mutation."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"it can focus on specified tree of the state."}]}]}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here is an example store, in this section we create a dispatcher to commit the mutation into this Store:"}]},{"type":"codeListing","syntax":"swift","code":["struct State: StateType {","  var count: Int = 0","}","","enum Activity {","  case happen","}","","final class MyStore: Store<State, Activity> {","  ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"MyStore has a typealias to define a dispatcher:"}]},{"type":"codeListing","syntax":"swift","code":["MyStore.Dispatcher"]},{"anchor":"Define-a-dispatcher","level":2,"type":"heading","text":"Define a dispatcher"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s take a look how we create a dispatcher with using the typealias:"}]},{"type":"codeListing","syntax":"swift","code":["final class MyDispatcher: MyStore.Dispatcher {","","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now we can create an instance of "},{"type":"codeVoice","code":"MyDispatcher"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let store = MyStore()","let dispatcher = MyDispatcher(targetStore: store)"]},{"anchor":"Add-an-action-to-the-dispatcher","level":2,"type":"heading","text":"Add an action to the dispatcher"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next, we add an action that commits a mutation:"}]},{"type":"codeListing","syntax":"swift","code":["final class MyDispatcher: MyStore.Dispatcher {","  func doSomething() {","    commit {","      $0.count = 100","    }","  }","}"]},{"type":"codeListing","syntax":"swift","code":["let store: MyStore","let dispatcher: MyDispatcher","","dispatcher.doSomething()","","store.state.count == 100 \/\/ true"]},{"anchor":"Add-a-dependency-to-dispatch-an-action","level":2,"type":"heading","text":"Add a dependency to dispatch an action"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the case of large applications, we need to handle many dependencies to run the application."},{"type":"text","text":" "},{"type":"text","text":"For example, if we use multiple HTTP clients."}]},{"type":"codeListing","syntax":"swift","code":["final class MyDispatcher: MyStore.Dispatcher {","","  let apiClient: APIClient","","  init(apiClient: APIClient, targetStore: Store<RootState>) {","    self.apiClient = apiClient","    super.init(targetStore: targetStore)","  }","","  \/\/ an example of fetching data and commit","  func fetchData() {","    apiClient.fetchData { [weak self] result in","      switch result {","      case .success(let data):","        let items = data.encode(...)","        self?.commit {","          $0.fetchedItems = items","        }","      case .failure(let error):","      \/\/ handles error","      }","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To use this:"}]},{"type":"codeListing","syntax":"swift","code":["let store = MyStore()","let apiClient = APIClient()","let dispatcher = MyDispatcher(apiClient: apiClient, target: store)","","dispatcher.fetchData()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now we can handle multiple kinds of dependencies each it fits itself life-time."},{"type":"text","text":" "},{"type":"text","text":"For example, if you have a restriction that some dependencies can be created only the user’s logging-in, you can create a dispatcher what is for."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next section explains the detail."}]},{"anchor":"Create-multiple-Dispatcher","level":2,"type":"heading","text":"Create multiple Dispatcher"},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"https:\/\/user-images.githubusercontent.com\/1888355\/82821486-28586a00-9edf-11ea-8c98-062eafcc4f16.png"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Creating a dispatcher does not have the restriction of the number of instances or types."},{"type":"text","text":" "},{"type":"text","text":"This means that it allows us to define a dispatcher and instantiate an instance of the dispatcher to fill the use-case."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, In case the timing of getting dependencies that to be needed by run Action or Mutation is different, it’s not easy to have them in the one dispatcher with type-safety. they must be optional types."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Using creating multiple dispatchers techniques solves this case by defines the dispatcher each the timing of getting dependencies."}]},{"type":"codeListing","syntax":"swift","code":["class LoggedInDispatcher: MyStore.Dispatcher {","","  let apiClientNeedsAuthToken: APIClient = ...","  ...","}","","class LoggedOutDispatcher: MyStore.Dispatcher {","","  let apiClientWithoutAuthToken: APIClient = ...","  ...","}"]},{"type":"codeListing","syntax":"swift","code":["let store = MyStore()","let loggedInDispatcher = LoggedInDispatcher(...)","let loggedOutDispatcher = LoggedOutDispatcher(...)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The application will create "},{"type":"codeVoice","code":"LoggedInDispatcher"},{"type":"text","text":" when the user is logged-in and deinitialize "},{"type":"codeVoice","code":"LoggedOutDispatcher"},{"type":"text","text":"."}]},{"anchor":"Create-scoped-dispatcher","level":2,"type":"heading","text":"Create scoped dispatcher"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As another feature what Dispatcher provides, It supports to commit specified scope of the state which helps to mutate with focus on a part of the large state tree."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here is a sample state that assuming a large app."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"AppState (MyStore)"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"db: Database"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"loggedIn: LoggedInState"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"myInfo: MyInfoState"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"loggedOut: LoggedOutState"}]}]}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We have "},{"type":"codeVoice","code":"database"},{"type":"text","text":", "},{"type":"codeVoice","code":"logged-in"},{"type":"text","text":" and "},{"type":"codeVoice","code":"logged-out state"},{"type":"text","text":". "},{"type":"codeVoice","code":"database"},{"type":"text","text":" means normalized state shape to manage many entities."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In previous section, that explained we can multiple dispatchers each the user’s state."},{"type":"text","text":" "},{"type":"text","text":"However, it needs to the full path to mutate where we need to mutate."}]},{"type":"codeListing","syntax":"swift","code":["class LoggedInDispatcher: MyStore.Dispatcher {","","  func performA() {","    commit {","      $0.loggedIn.xxx","    }","  }","","  func performB() {","    commit {","      $0.loggedIn.xxx","    }","  }","","  func performC() {","    commit {","      $0.loggedIn.xxx","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"LoggedInDispatcher will often dispatch some action for logged-in-state."},{"type":"text","text":" "},{"type":"text","text":"But it calls everytime "},{"type":"codeVoice","code":"$0.loggedIn"},{"type":"text","text":", it seems a little bit verbosity."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That will be solved by "},{"type":"codeVoice","code":"ScopedDispatcher"},{"type":"text","text":". It will move on target tree of the state when it dispatch the action."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following code shows how we could create a "},{"type":"codeVoice","code":"ScopedDispatcher"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["final class LoggedInService: MyStore.ScopedDispatcher<LoggedInState> {","","  init(store: Store) {","    super.init(targetStore: store, scope: \\.loggedIn)","  }","","  func someOperation() {","    commit { (state: LoggedInState) in","      ...","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In LoggedInService, commit mutates "},{"type":"codeVoice","code":"LoggedInState"},{"type":"text","text":" directly. Like this, we can create a dispatcher each use-cases."}]},{"anchor":"Detaching-to-other-tree","level":3,"type":"heading","text":"Detaching to other tree"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Just in case, "},{"type":"codeVoice","code":"ScopedDispatcher"},{"type":"text","text":" supports also mutating on other state tree."}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Moving on more deeper"}]}]},{"type":"codeListing","syntax":"swift","code":["final class LoggedInService: MyStore.ScopedDispatcher<LoggedInState> {","","  func detachingOperation() {","    let myInfo = detached(by: \\.myInfo)","    myInfo.commit { (state: MyInfo) in","","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Detaches from root"}]}]},{"type":"codeListing","syntax":"swift","code":["final class LoggedInService: MyStore.ScopedDispatcher<LoggedInState> {","","  func detachingOperation() {","    let db = detached(from: \\.db)","    db.commit { (state: Database) in","","    }","  }","}"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/verge\/dispatchertype"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Verge\/documentation\/Verge\/DispatcherType","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Dispatcher allows us to update the state of the Store from away the store and to manage dependencies to create Mutation."}],"kind":"symbol","metadata":{"navigatorTitle":[{"kind":"identifier","text":"DispatcherType"}],"role":"symbol","title":"DispatcherType","roleHeading":"Type Alias","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"DispatcherType"}],"symbolKind":"typealias","externalID":"s:5Verge14DispatcherTypea","modules":[{"name":"Verge"}],"platforms":[]},"hierarchy":{"paths":[["doc:\/\/Verge\/documentation\/Verge"]]},"seeAlsoSections":[{"title":"Essentials","identifiers":["doc:\/\/Verge\/documentation\/Verge\/Store","doc:\/\/Verge\/documentation\/Verge\/Changes","doc:\/\/Verge\/documentation\/Verge\/Derived"],"generated":true}],"references":{"https://user-images.githubusercontent.com/1888355/82821486-28586a00-9edf-11ea-8c98-062eafcc4f16.png":{"alt":"https:\/\/user-images.githubusercontent.com\/1888355\/82821486-28586a00-9edf-11ea-8c98-062eafcc4f16.png","type":"image","identifier":"https:\/\/user-images.githubusercontent.com\/1888355\/82821486-28586a00-9edf-11ea-8c98-062eafcc4f16.png","variants":[{"url":"https:\/\/user-images.githubusercontent.com\/1888355\/82821486-28586a00-9edf-11ea-8c98-062eafcc4f16.png","traits":["1x","light"]}]},"doc://Verge/documentation/Verge/DispatcherType":{"deprecated":true,"role":"symbol","title":"DispatcherType","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"DispatcherType"}],"abstract":[{"type":"text","text":"Dispatcher allows us to update the state of the Store from away the store and to manage dependencies to create Mutation."}],"identifier":"doc:\/\/Verge\/documentation\/Verge\/DispatcherType","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DispatcherType"}],"url":"\/documentation\/verge\/dispatchertype"},"doc://Verge/documentation/Verge/Store":{"role":"symbol","title":"Store","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Store"}],"abstract":[{"type":"text","text":"An object that retains a latest state value and receives mutations that modify itself state."},{"type":"text","text":" "},{"type":"text","text":"Those updates would be shared all of the subscribers these are sink(s), Derived(s)"}],"identifier":"doc:\/\/Verge\/documentation\/Verge\/Store","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Store"}],"url":"\/documentation\/verge\/store"},"doc://Verge/documentation/Verge/StoreDriverType":{"role":"symbol","title":"StoreDriverType","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"StoreDriverType"}],"abstract":[{"type":"text","text":"A protocol that uses external Store inside and provides the functions."}],"identifier":"doc:\/\/Verge\/documentation\/Verge\/StoreDriverType","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"StoreDriverType"}],"url":"\/documentation\/verge\/storedrivertype"},"doc://Verge/documentation/Verge":{"role":"collection","title":"Verge","abstract":[],"identifier":"doc:\/\/Verge\/documentation\/Verge","kind":"symbol","type":"topic","url":"\/documentation\/verge"},"doc://Verge/documentation/Verge/Derived":{"role":"symbol","title":"Derived","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Derived"}],"abstract":[{"type":"text","text":"A container object that provides the current value and changes from the source Store."}],"identifier":"doc:\/\/Verge\/documentation\/Verge\/Derived","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Derived"}],"url":"\/documentation\/verge\/derived"},"doc://Verge/documentation/Verge/Changes":{"role":"symbol","title":"Changes","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Changes"}],"abstract":[{"type":"text","text":"An immutable data object to achieve followings:"}],"identifier":"doc:\/\/Verge\/documentation\/Verge\/Changes","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Changes"}],"url":"\/documentation\/verge\/changes"}}}